{
  "language": "Solidity",
  "sources": {
    "contracts/Gauge/CrossChainRewarder.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {ERC20} from \"solmate/src/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"solmate/src/utils/SafeTransferLib.sol\";\nimport {ReentrancyGuard} from \"solmate/src/utils/ReentrancyGuard.sol\";\n\nimport \"../Staking/Owned.sol\";\n\ncontract CrossChainRewarder is Owned, ReentrancyGuard {\n    using SafeTransferLib for ERC20;\n\n    /* ========== STATE VARIABLES ========== */\n\n    // Instances and addresses\n    address public immutable reward_token_address;\n\n    // Admin addresses\n    address public timelock_address;\n    address public curator_address;\n\n    // Farm address\n    address public farm_address;\n\n    // Booleans\n    bool public distributionsOn;\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyByOwnGov() {\n        require(\n            msg.sender == owner || msg.sender == timelock_address,\n            \"Not owner or timelock\"\n        );\n        _;\n    }\n\n    modifier onlyByOwnerOrCuratorOrGovernance() {\n        require(\n            msg.sender == owner ||\n                msg.sender == curator_address ||\n                msg.sender == timelock_address,\n            \"Not owner, curator, or timelock\"\n        );\n        _;\n    }\n\n    modifier isDistributing() {\n        require(distributionsOn == true, \"Distributions are off\");\n        _;\n    }\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(\n        address _owner,\n        address _curator_address,\n        address _reward_token_address\n    ) Owned(_owner) {\n        curator_address = _curator_address;\n        reward_token_address = _reward_token_address;\n\n        distributionsOn = true;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    // Callable by anyone\n    function distributeReward()\n        public\n        isDistributing\n        nonReentrant\n        returns (uint256 reward_balance)\n    {\n        // Get the reward balance\n        reward_balance = ERC20(reward_token_address).balanceOf(address(this));\n\n        // Pay out the rewards directly to the farm\n        ERC20(reward_token_address).safeTransfer(farm_address, reward_balance);\n\n        emit RewardDistributed(farm_address, reward_balance);\n    }\n\n    /* ========== RESTRICTED FUNCTIONS - Curator / migrator callable ========== */\n\n    // For emergency situations\n    function toggleDistributions() external onlyByOwnerOrCuratorOrGovernance {\n        distributionsOn = !distributionsOn;\n\n        emit DistributionsToggled(distributionsOn);\n    }\n\n    /* ========== RESTRICTED FUNCTIONS - Owner or timelock only ========== */\n\n    // Added to support recovering LP Rewards and other mistaken tokens from other systems to be distributed to holders\n    function recoverERC20(address tokenAddress, uint256 tokenAmount)\n        external\n        onlyByOwnGov\n    {\n        // Only the owner address can ever receive the recovery withdrawal\n        ERC20(tokenAddress).safeTransfer(owner, tokenAmount);\n        emit RecoveredERC20(tokenAddress, tokenAmount);\n    }\n\n    // Generic proxy\n    function execute(\n        address _to,\n        uint256 _value,\n        bytes calldata _data\n    ) external onlyByOwnGov returns (bool, bytes memory) {\n        (bool success, bytes memory result) = _to.call{value: _value}(_data);\n        return (success, result);\n    }\n\n    function setFarmAddress(address _farm_address) external onlyByOwnGov {\n        farm_address = _farm_address;\n\n        emit FarmAddressChanged(farm_address);\n    }\n\n    function setTimelock(address _new_timelock) external onlyByOwnGov {\n        timelock_address = _new_timelock;\n    }\n\n    function setCurator(address _new_curator_address) external onlyByOwnGov {\n        curator_address = _new_curator_address;\n    }\n\n    /* ========== EVENTS ========== */\n\n    event RewardDistributed(\n        address indexed farm_address,\n        uint256 reward_amount\n    );\n    event RecoveredERC20(address token, uint256 amount);\n    event FarmAddressChanged(address farm_address);\n    event DistributionsToggled(bool distibutions_state);\n}\n"
    },
    "solmate/src/tokens/ERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
    },
    "solmate/src/utils/SafeTransferLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    /*//////////////////////////////////////////////////////////////\n                             ETH OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), from) // Append the \"from\" argument.\n            mstore(add(freeMemoryPointer, 36), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"APPROVE_FAILED\");\n    }\n}\n"
    },
    "solmate/src/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Gas optimized reentrancy protection for smart contracts.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/ReentrancyGuard.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\nabstract contract ReentrancyGuard {\n    uint256 private locked = 1;\n\n    modifier nonReentrant() virtual {\n        require(locked == 1, \"REENTRANCY\");\n\n        locked = 2;\n\n        _;\n\n        locked = 1;\n    }\n}\n"
    },
    "contracts/Staking/Owned.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.6.11;\n\n// https://docs.synthetix.io/contracts/Owned\ncontract Owned {\n    address public owner;\n    address public nominatedOwner;\n\n    constructor(address _owner) {\n        require(_owner != address(0), \"Owner address cannot be 0\");\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }\n\n    function nominateNewOwner(address _owner) external onlyOwner {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n\n    function acceptOwnership() external {\n        require(\n            msg.sender == nominatedOwner,\n            \"You must be nominated before you can accept ownership\"\n        );\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n\n    modifier onlyOwner() {\n        require(\n            msg.sender == owner,\n            \"Only the contract owner may perform this action\"\n        );\n        _;\n    }\n\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n}\n"
    },
    "contracts/Gauge/MiddlemanGauge.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {ERC20} from \"solmate/src/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"solmate/src/utils/SafeTransferLib.sol\";\nimport {ReentrancyGuard} from \"solmate/src/utils/ReentrancyGuard.sol\";\n\nimport \"./IGaugeRewardsDistributor.sol\";\nimport \"../Misc_AMOs/harmony/IERC20EthManager.sol\";\nimport \"../Misc_AMOs/polygon/IRootChainManager.sol\";\nimport \"../Misc_AMOs/solana/IWormhole.sol\";\nimport \"../Staking/Owned.sol\";\n\ncontract MiddlemanGauge is Owned, ReentrancyGuard {\n    using SafeTransferLib for ERC20;\n\n    /* ========== STATE VARIABLES ========== */\n\n    address public immutable reward_token_address;\n\n    // Instances and addresses\n    address public rewards_distributor_address;\n\n    // Informational\n    string public name;\n\n    // Admin addresses\n    address public timelock_address;\n\n    // Tracking\n    uint32 public fake_nonce;\n\n    // Gauge-related\n    uint32 public bridge_type;\n    address public bridge_address;\n    address public destination_address_override;\n    string public non_evm_destination_address;\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyByOwnGov() {\n        require(\n            msg.sender == owner || msg.sender == timelock_address,\n            \"Not owner or timelock\"\n        );\n        _;\n    }\n\n    modifier onlyRewardsDistributor() {\n        require(\n            msg.sender == rewards_distributor_address,\n            \"Not rewards distributor\"\n        );\n        _;\n    }\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(\n        address _owner,\n        address _reward_token_address,\n        address _timelock_address,\n        address _rewards_distributor_address,\n        address _bridge_address,\n        uint32 _bridge_type,\n        address _destination_address_override,\n        string memory _non_evm_destination_address,\n        string memory _name\n    ) Owned(_owner) {\n        reward_token_address = _reward_token_address;\n        timelock_address = _timelock_address;\n\n        rewards_distributor_address = _rewards_distributor_address;\n\n        bridge_address = _bridge_address;\n        bridge_type = _bridge_type;\n        destination_address_override = _destination_address_override;\n        non_evm_destination_address = _non_evm_destination_address;\n\n        name = _name;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    // Callable only by the rewards distributor\n    function pullAndBridge(uint256 reward_amount)\n        external\n        onlyRewardsDistributor\n        nonReentrant\n    {\n        require(bridge_address != address(0), \"Invalid bridge address\");\n\n        // Pull in the rewards from the rewards distributor\n        ERC20(reward_token_address).safeTransferFrom(\n            rewards_distributor_address,\n            address(this),\n            reward_amount\n        );\n\n        address address_to_send_to = address(this);\n        if (destination_address_override != address(0))\n            address_to_send_to = destination_address_override;\n\n        if (bridge_type == 0) {\n            // Avalanche [Anyswap]\n            ERC20(reward_token_address).safeTransfer(\n                bridge_address,\n                reward_amount\n            );\n        } else if (bridge_type == 1) {\n            // BSC\n            ERC20(reward_token_address).safeTransfer(\n                bridge_address,\n                reward_amount\n            );\n        } else if (bridge_type == 2) {\n            // Fantom [Multichain / Anyswap]\n            // Bridge is 0xC564EE9f21Ed8A2d8E7e76c085740d5e4c5FaFbE\n            ERC20(reward_token_address).safeTransfer(\n                bridge_address,\n                reward_amount\n            );\n        } else if (bridge_type == 3) {\n            // Polygon\n            // Bridge is 0xA0c68C638235ee32657e8f720a23ceC1bFc77C77\n            // Interesting info https://blog.cryption.network/cryption-network-launches-cross-chain-staking-6cf000c25477\n\n            // Approve\n            IRootChainManager rootChainMgr = IRootChainManager(bridge_address);\n            bytes32 tokenType = rootChainMgr.tokenToType(reward_token_address);\n            address predicate = rootChainMgr.typeToPredicate(tokenType);\n            ERC20(reward_token_address).approve(predicate, reward_amount);\n\n            // DepositFor\n            bytes memory depositData = abi.encode(reward_amount);\n            rootChainMgr.depositFor(\n                address_to_send_to,\n                reward_token_address,\n                depositData\n            );\n        } else if (bridge_type == 4) {\n            // Solana\n            // Wormhole Bridge is 0xf92cD566Ea4864356C5491c177A430C222d7e678\n\n            revert(\"Not supported yet\");\n\n            // // Approve\n            // ERC20(reward_token_address).approve(bridge_address, reward_amount);\n\n            // // lockAssets\n            // require(non_evm_destination_address != 0, \"Invalid destination\");\n            // // non_evm_destination_address = base58 -> hex\n            // // https://www.appdevtools.com/base58-encoder-decoder\n            // IWormhole(bridge_address).lockAssets(\n            //     reward_token_address,\n            //     reward_amount,\n            //     non_evm_destination_address,\n            //     1,\n            //     fake_nonce,\n            //     false\n            // );\n        } else if (bridge_type == 5) {\n            // Harmony\n            // Bridge is at 0x2dccdb493827e15a5dc8f8b72147e6c4a5620857\n\n            // Approve\n            ERC20(reward_token_address).approve(bridge_address, reward_amount);\n\n            // lockToken\n            IERC20EthManager(bridge_address).lockToken(\n                reward_token_address,\n                reward_amount,\n                address_to_send_to\n            );\n        }\n\n        // fake_nonce += 1;\n    }\n\n    /* ========== RESTRICTED FUNCTIONS - Owner or timelock only ========== */\n\n    // Added to support recovering LP Rewards and other mistaken tokens from other systems to be distributed to holders\n    function recoverERC20(address tokenAddress, uint256 tokenAmount)\n        external\n        onlyByOwnGov\n    {\n        // Only the owner address can ever receive the recovery withdrawal\n        ERC20(tokenAddress).safeTransfer(owner, tokenAmount);\n        emit RecoveredERC20(tokenAddress, tokenAmount);\n    }\n\n    // Generic proxy\n    function execute(\n        address _to,\n        uint256 _value,\n        bytes calldata _data\n    ) external onlyByOwnGov returns (bool, bytes memory) {\n        (bool success, bytes memory result) = _to.call{value: _value}(_data);\n        return (success, result);\n    }\n\n    function setTimelock(address _new_timelock) external onlyByOwnGov {\n        timelock_address = _new_timelock;\n    }\n\n    function setBridgeInfo(\n        address _bridge_address,\n        uint32 _bridge_type,\n        address _destination_address_override,\n        string memory _non_evm_destination_address\n    ) external onlyByOwnGov {\n        bridge_address = _bridge_address;\n\n        // 0: Avalanche\n        // 1: BSC\n        // 2: Fantom\n        // 3: Polygon\n        // 4: Solana\n        // 5: Harmony\n        bridge_type = _bridge_type;\n\n        // Overridden cross-chain destination address\n        destination_address_override = _destination_address_override;\n\n        // Set bytes32 / non-EVM address on the other chain, if applicable\n        non_evm_destination_address = _non_evm_destination_address;\n\n        emit BridgeInfoChanged(\n            _bridge_address,\n            _bridge_type,\n            _destination_address_override,\n            _non_evm_destination_address\n        );\n    }\n\n    function setRewardsDistributor(address _rewards_distributor_address)\n        external\n        onlyByOwnGov\n    {\n        rewards_distributor_address = _rewards_distributor_address;\n    }\n\n    /* ========== EVENTS ========== */\n\n    event RecoveredERC20(address token, uint256 amount);\n    event BridgeInfoChanged(\n        address bridge_address,\n        uint256 bridge_type,\n        address destination_address_override,\n        string non_evm_destination_address\n    );\n}\n"
    },
    "contracts/Gauge/IGaugeRewardsDistributor.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.6.11;\n\ninterface IGaugeRewardsDistributor {\n    function acceptOwnership() external;\n\n    function curator_address() external view returns (address);\n\n    function currentReward(address gauge_address)\n        external\n        view\n        returns (uint256 reward_amount);\n\n    function distributeReward(address gauge_address)\n        external\n        returns (uint256 weeks_elapsed, uint256 reward_tally);\n\n    function distributionsOn() external view returns (bool);\n\n    function gauge_whitelist(address) external view returns (bool);\n\n    function is_middleman(address) external view returns (bool);\n\n    function last_time_gauge_paid(address) external view returns (uint256);\n\n    function nominateNewOwner(address _owner) external;\n\n    function nominatedOwner() external view returns (address);\n\n    function owner() external view returns (address);\n\n    function recoverERC20(address tokenAddress, uint256 tokenAmount) external;\n\n    function setCurator(address _new_curator_address) external;\n\n    function setGaugeController(address _gauge_controller_address) external;\n\n    function setGaugeState(\n        address _gauge_address,\n        bool _is_middleman,\n        bool _is_active\n    ) external;\n\n    function setTimelock(address _new_timelock) external;\n\n    function timelock_address() external view returns (address);\n\n    function toggleDistributions() external;\n}\n"
    },
    "contracts/Misc_AMOs/harmony/IERC20EthManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.6.11;\npragma experimental ABIEncoderV2;\n\ninterface IERC20EthManager {\n    function lockToken(\n        address ethTokenAddr,\n        uint256 amount,\n        address recipient\n    ) external;\n\n    function lockTokenFor(\n        address ethTokenAddr,\n        address userAddr,\n        uint256 amount,\n        address recipient\n    ) external;\n\n    function unlockToken(\n        address ethTokenAddr,\n        uint256 amount,\n        address recipient,\n        bytes32 receiptId\n    ) external;\n\n    function usedEvents_(bytes32) external view returns (bool);\n\n    function wallet() external view returns (address);\n}\n"
    },
    "contracts/Misc_AMOs/polygon/IRootChainManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.6.11;\npragma experimental ABIEncoderV2;\n\ninterface IRootChainManager {\n    function depositFor(\n        address user,\n        address rootToken,\n        bytes memory depositData\n    ) external;\n\n    function tokenToType(address) external view returns (bytes32);\n\n    function typeToPredicate(bytes32) external view returns (address);\n}\n"
    },
    "contracts/Misc_AMOs/solana/IWormhole.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.6.11;\npragma experimental ABIEncoderV2;\n\ninterface IWormhole {\n    function guardian_set_expirity() external view returns (uint32);\n\n    function guardian_set_index() external view returns (uint32);\n\n    function guardian_sets(uint32)\n        external\n        view\n        returns (uint32 expiration_time);\n\n    function isWrappedAsset(address) external view returns (bool);\n\n    function lockAssets(\n        address asset,\n        uint256 amount,\n        bytes32 recipient,\n        uint8 target_chain,\n        uint32 nonce,\n        bool refund_dust\n    ) external;\n\n    function lockETH(\n        bytes32 recipient,\n        uint8 target_chain,\n        uint32 nonce\n    ) external;\n\n    function wrappedAssetMaster() external view returns (address);\n\n    function wrappedAssets(bytes32) external view returns (address);\n}\n"
    },
    "contracts/Gauge/GaugeRewardsDistributor.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {ERC20} from \"solmate/src/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"solmate/src/utils/SafeTransferLib.sol\";\nimport {ReentrancyGuard} from \"solmate/src/utils/ReentrancyGuard.sol\";\n\nimport \"./IGaugeController.sol\";\nimport {MiddlemanGauge} from \"./MiddlemanGauge.sol\";\nimport \"../Staking/Owned.sol\";\n\ncontract GaugeRewardsDistributor is Owned, ReentrancyGuard {\n    using SafeTransferLib for ERC20;\n\n    /* ========== STATE VARIABLES ========== */\n\n    // Instances and addresses\n    address public immutable reward_token_address;\n    IGaugeController public gauge_controller;\n\n    // Admin addresses\n    address public timelock_address;\n    address public curator_address;\n\n    // Constants\n    uint256 private constant MULTIPLIER_PRECISION = 1e18;\n    uint256 private constant ONE_WEEK = 604800;\n\n    // Gauge controller related\n    mapping(address => bool) public gauge_whitelist;\n    mapping(address => bool) public is_middleman; // For cross-chain farms, use a middleman contract to push to a bridge\n    mapping(address => uint256) public last_time_gauge_paid;\n\n    // Booleans\n    bool public distributionsOn;\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyByOwnGov() {\n        require(\n            msg.sender == owner || msg.sender == timelock_address,\n            \"Not owner or timelock\"\n        );\n        _;\n    }\n\n    modifier onlyByOwnerOrCuratorOrGovernance() {\n        require(\n            msg.sender == owner ||\n                msg.sender == curator_address ||\n                msg.sender == timelock_address,\n            \"Not owner, curator, or timelock\"\n        );\n        _;\n    }\n\n    modifier isDistributing() {\n        require(distributionsOn == true, \"Distributions are off\");\n        _;\n    }\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(\n        address _owner,\n        address _timelock_address,\n        address _curator_address,\n        address _reward_token_address,\n        address _gauge_controller_address\n    ) Owned(_owner) {\n        curator_address = _curator_address;\n        timelock_address = _timelock_address;\n\n        reward_token_address = _reward_token_address;\n        gauge_controller = IGaugeController(_gauge_controller_address);\n\n        distributionsOn = true;\n    }\n\n    /* ========== VIEWS ========== */\n\n    // Current weekly reward amount\n    function currentReward(address gauge_address)\n        public\n        view\n        returns (uint256 reward_amount)\n    {\n        uint256 rel_weight = gauge_controller.gauge_relative_weight(\n            gauge_address,\n            block.timestamp\n        );\n        uint256 rwd_rate = ((gauge_controller.global_emission_rate()) *\n            rel_weight) / 1e18;\n        reward_amount = rwd_rate * ONE_WEEK;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    // Callable by anyone\n    function distributeReward(address gauge_address)\n        public\n        isDistributing\n        nonReentrant\n        returns (uint256 weeks_elapsed, uint256 reward_tally)\n    {\n        require(gauge_whitelist[gauge_address], \"Gauge not whitelisted\");\n\n        // Calculate the elapsed time in weeks.\n        uint256 last_time_paid = last_time_gauge_paid[gauge_address];\n\n        // Edge case for first reward for this gauge\n        if (last_time_paid == 0) {\n            weeks_elapsed = 1;\n        } else {\n            // Truncation desired\n            weeks_elapsed =\n                (block.timestamp - last_time_gauge_paid[gauge_address]) /\n                ONE_WEEK;\n\n            // Return early here for 0 weeks instead of throwing, as it could have bad effects in other contracts\n            if (weeks_elapsed == 0) {\n                return (0, 0);\n            }\n        }\n\n        // NOTE: This will always use the current global_emission_rate()\n        reward_tally = 0;\n        for (uint256 i = 0; i < (weeks_elapsed); i++) {\n            uint256 rel_weight_at_week;\n            if (i == 0) {\n                // Mutative, for the current week. Makes sure the weight is checkpointed. Also returns the weight.\n                rel_weight_at_week = gauge_controller\n                    .gauge_relative_weight_write(\n                        gauge_address,\n                        block.timestamp\n                    );\n            } else {\n                // View\n                rel_weight_at_week = gauge_controller.gauge_relative_weight(\n                    gauge_address,\n                    block.timestamp - (ONE_WEEK * i)\n                );\n            }\n            uint256 rwd_rate_at_week = (gauge_controller\n                .global_emission_rate() * rel_weight_at_week) / 1e18;\n            reward_tally = reward_tally + rwd_rate_at_week * ONE_WEEK;\n        }\n\n        // Update the last time paid\n        last_time_gauge_paid[gauge_address] = block.timestamp;\n\n        if (is_middleman[gauge_address]) {\n            // Cross chain: Pay out the rewards to the middleman contract\n            // Approve for the middleman first\n            ERC20(reward_token_address).approve(gauge_address, reward_tally);\n\n            // Trigger the middleman\n            MiddlemanGauge(gauge_address).pullAndBridge(reward_tally);\n        } else {\n            // Mainnet: Pay out the rewards directly to the gauge\n            ERC20(reward_token_address).safeTransfer(\n                gauge_address,\n                reward_tally\n            );\n        }\n\n        emit RewardDistributed(gauge_address, reward_tally);\n    }\n\n    /* ========== RESTRICTED FUNCTIONS - Curator / migrator callable ========== */\n\n    // For emergency situations\n    function toggleDistributions() external onlyByOwnerOrCuratorOrGovernance {\n        distributionsOn = !distributionsOn;\n\n        emit DistributionsToggled(distributionsOn);\n    }\n\n    /* ========== RESTRICTED FUNCTIONS - Owner or timelock only ========== */\n\n    // Added to support recovering LP Rewards and other mistaken tokens from other systems to be distributed to holders\n    function recoverERC20(address tokenAddress, uint256 tokenAmount)\n        external\n        onlyByOwnGov\n    {\n        // Only the owner address can ever receive the recovery withdrawal\n        ERC20(tokenAddress).safeTransfer(owner, tokenAmount);\n        emit RecoveredERC20(tokenAddress, tokenAmount);\n    }\n\n    function setGaugeState(\n        address _gauge_address,\n        bool _is_middleman,\n        bool _is_active\n    ) external onlyByOwnGov {\n        is_middleman[_gauge_address] = _is_middleman;\n        gauge_whitelist[_gauge_address] = _is_active;\n\n        emit GaugeStateChanged(_gauge_address, _is_middleman, _is_active);\n    }\n\n    function setTimelock(address _new_timelock) external onlyByOwnGov {\n        timelock_address = _new_timelock;\n    }\n\n    function setCurator(address _new_curator_address) external onlyByOwnGov {\n        curator_address = _new_curator_address;\n    }\n\n    function setGaugeController(address _gauge_controller_address)\n        external\n        onlyByOwnGov\n    {\n        gauge_controller = IGaugeController(_gauge_controller_address);\n    }\n\n    /* ========== EVENTS ========== */\n\n    event RewardDistributed(\n        address indexed gauge_address,\n        uint256 reward_amount\n    );\n    event RecoveredERC20(address token, uint256 amount);\n    event GaugeStateChanged(\n        address gauge_address,\n        bool is_middleman,\n        bool is_active\n    );\n    event DistributionsToggled(bool distibutions_state);\n}\n"
    },
    "contracts/Gauge/IGaugeController.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.6.11;\n\n// https://github.com/swervefi/swerve/edit/master/packages/swerve-contracts/interfaces/IGaugeController.sol\n\ninterface IGaugeController {\n    struct Point {\n        uint256 bias;\n        uint256 slope;\n    }\n\n    struct VotedSlope {\n        uint256 slope;\n        uint256 power;\n        uint256 end;\n    }\n\n    // Public variables\n    function admin() external view returns (address);\n\n    function future_admin() external view returns (address);\n\n    function token() external view returns (address);\n\n    function voting_escrow() external view returns (address);\n\n    function n_gauge_types() external view returns (int128);\n\n    function n_gauges() external view returns (int128);\n\n    function gauge_type_names(int128) external view returns (string memory);\n\n    function gauges(uint256) external view returns (address);\n\n    function vote_user_slopes(address, address)\n        external\n        view\n        returns (VotedSlope memory);\n\n    function vote_user_power(address) external view returns (uint256);\n\n    function last_user_vote(address, address) external view returns (uint256);\n\n    function points_weight(address, uint256)\n        external\n        view\n        returns (Point memory);\n\n    function time_weight(address) external view returns (uint256);\n\n    function points_sum(int128, uint256) external view returns (Point memory);\n\n    function time_sum(uint256) external view returns (uint256);\n\n    function points_total(uint256) external view returns (uint256);\n\n    function time_total() external view returns (uint256);\n\n    function points_type_weight(int128, uint256)\n        external\n        view\n        returns (uint256);\n\n    function time_type_weight(uint256) external view returns (uint256);\n\n    // Getter functions\n    function gauge_types(address) external view returns (int128);\n\n    function gauge_relative_weight(address) external view returns (uint256);\n\n    function gauge_relative_weight(address, uint256)\n        external\n        view\n        returns (uint256);\n\n    function get_gauge_weight(address) external view returns (uint256);\n\n    function get_type_weight(int128) external view returns (uint256);\n\n    function get_total_weight() external view returns (uint256);\n\n    function get_weights_sum_per_type(int128) external view returns (uint256);\n\n    // External functions\n    function commit_transfer_ownership(address) external;\n\n    function apply_transfer_ownership() external;\n\n    function add_gauge(\n        address,\n        int128,\n        uint256\n    ) external;\n\n    function checkpoint() external;\n\n    function checkpoint_gauge(address) external;\n\n    function global_emission_rate() external view returns (uint256);\n\n    function gauge_relative_weight_write(address) external returns (uint256);\n\n    function gauge_relative_weight_write(address, uint256)\n        external\n        returns (uint256);\n\n    function add_type(string memory, uint256) external;\n\n    function change_type_weight(int128, uint256) external;\n\n    function change_gauge_weight(address, uint256) external;\n\n    function change_global_emission_rate(uint256) external;\n\n    function vote_for_gauge_weights(address, uint256) external;\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}